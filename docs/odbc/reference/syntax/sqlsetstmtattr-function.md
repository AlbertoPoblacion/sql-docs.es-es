---
title: Función SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 583639a5cd4680bf6cfcf03bbaf6ee9eb63adba8
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/15/2019
ms.locfileid: "68039647"
---
# <a name="sqlsetstmtattr-function"></a>Función SQLSetStmtAttr
**Conformidad**  
 Versión de introducción: Compatibilidad de ODBC 3.0 estándares: ISO 92  
  
 **Resumen**  
 **SQLSetStmtAttr** establece los atributos relacionados con una instrucción.  
  
> [!NOTE]
>  Para obtener más información sobre lo que el Administrador de controladores se asigna esta función cuando un ODBC *3.x* aplicación funciona con un ODBC *2.x* controladores, consulte [asignación de funciones de reemplazo para hacia atrás Compatibilidad de aplicaciones](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxis  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Identificador de instrucción.  
  
 *Atributo*  
 [Entrada] Opción para establecer, aparecen en "Comentarios".  
  
 *ValuePtr*  
 [Entrada] Valor que se asociará con *atributo*. Dependiendo del valor de *atributo*, *ValuePtr* será uno de los siguientes:  
  
-   Un identificador de descriptor de ODBC.  
  
-   Un valor SQLUINTEGER.  
  
-   Un valor SQLULEN.  
  
-   Un puntero a uno de los siguientes:  
  
    -   Una cadena de caracteres terminada en null.  
  
    -   Un búfer binario.  
  
    -   Un valor o una matriz de tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valor definido por el controlador.  
  
 Si el *atributo* argumento es un valor específico del controlador, *ValuePtr* puede ser un entero con signo.  
  
 *StringLength*  
 [Entrada] Si *atributo* es un atributo definido por el ODBC y *ValuePtr* apunta a un búfer binario o una cadena de caracteres, este argumento debe ser la longitud de \* *ValuePtr*. Si *atributo* es un atributo definido por el ODBC y *ValuePtr* es un entero, *StringLength* se omite.  
  
 Si *atributo* es un atributo definido por el controlador, la aplicación indica la naturaleza del atributo para el Administrador de controladores al establecer el *StringLength* argumento. *StringLength* puede tener los siguientes valores:  
  
-   Si *ValuePtr* es un puntero a una cadena de caracteres, a continuación, *StringLength* es la longitud de la cadena o SQL_NTS.  
  
-   Si *ValuePtr* es un puntero a un búfer binario, a continuación, la aplicación, el resultado de la SQL_LEN_BINARY_ATTR (*longitud*) macro en *StringLength*. Esto coloca un valor negativo en *StringLength*.  
  
-   Si *ValuePtr* es un puntero a un valor distinto de una cadena de caracteres o una cadena binaria, a continuación, *StringLength* debe tener el valor SQL_IS_POINTER.  
  
-   Si *ValuePtr* contiene un valor de longitud fija, a continuación, *StringLength* es SQL_IS_INTEGER o SQL_IS_UINTEGER, según corresponda.  
  
## <a name="returns"></a>Devuelve  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnóstico  
 Cuando **SQLSetStmtAttr** devuelve SQL_ERROR o SQL_SUCCESS_WITH_INFO, un valor SQLSTATE asociado se puede obtener mediante una llamada a **SQLGetDiagRec** con un *HandleType* de SQL _HANDLE_STMT y un *controlar* de *StatementHandle*. En la tabla siguiente se enumera los valores SQLSTATE devueltos normalmente por **SQLSetStmtAttr** y se explica cada uno de ellos en el contexto de esta función; la notación "(DM)" precede a las descripciones de SQLSTATE devuelto por el Administrador de controladores. El código de retorno asociado a cada valor SQLSTATE es SQL_ERROR, a menos que se indique lo contrario.  
  
|SQLSTATE|Error|Descripción|  
|--------------|-----------|-----------------|  
|01000|Advertencia general|Específico del controlador de mensaje informativo. (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|01S02|Valor de opción cambiado|El controlador no eran compatibles con el valor especificado en *ValuePtr*, o el valor especificado en *ValuePtr* no era válido debido a las condiciones de trabajo de implementación, por lo que el controlador sustituye un valor similar. (**SQLGetStmtAttr** se puede llamar para determinar el valor sustituido temporalmente.) El valor de reemplazo es válido para el *StatementHandle* hasta que se cierra el cursor, momento en que el atributo de instrucción revierte a su valor anterior. Los atributos de instrucción que se pueden cambiar son:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT  SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|08S01|Error de vínculo de comunicación|Error en el vínculo de comunicación entre el controlador y el origen de datos a la que se ha conectado el controlador antes del procesamiento de la función se ha completado.|  
|24000|Estado de cursor no válido|El *atributo* era SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS y el cursor estaba abierto.|  
|HY000|Error general|Se produjo un error para que se ha producido ningún SQLSTATE específico y para los que se ha definido ningún SQLSTATE específicos de la implementación. El mensaje de error devuelto por **SQLGetDiagRec** en el  *\*MessageText* búfer describe el error y su causa.|  
|HY001|Error de asignación de memoria|El controlador no pudo asignar la memoria necesaria para admitir la ejecución o la finalización de la función.|  
|HY009|Uso no válido del puntero nulo|El *atributo* argumento identifica un atributo de instrucción que requiere un atributo de cadena, y el *ValuePtr* argumento era un puntero nulo.|  
|HY010|Error de secuencia de función|(DM) se llamó a una función que se ejecuta de forma asincrónica para el identificador de conexión que está asociado el *StatementHandle*. Aún estaba ejecutando esta función asincrónica cuando el **SQLSetStmtAttr** se llamó a la función.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, o **SQLMoreResults** se llamó para el *StatementHandle* y devuelven SQL_PARAM_DATA_ ESTÁ DISPONIBLE. Esta función se invoca antes de que se recuperan los datos para todos los parámetros transmitidos.<br /><br /> (DM) se llamó a una función que se ejecuta de forma asincrónica para la *StatementHandle* y aún se estaba ejecutando cuando se llamó a esta función.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, o **SQLSetPos** se llamó para el  *StatementHandle* y devuelve SQL_NEED_DATA. Esta función se invoca antes de que se enviaron datos para todas las columnas o parámetros de datos en ejecución.|  
|HY011|Atributo no se puede establecer ahora|El *atributo* era SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR o SQL_ ATTR_USE_BOOKMARKS y se ha preparado la instrucción.|  
|HY013|Error de administración de memoria|No se pudo procesar la llamada de función porque los objetos de memoria subyacente no se podrían tener acceso, posiblemente debido a memoria insuficiente.|  
|HY017|Uso no válido de un identificador de descriptor asignado automáticamente|(DM) el *atributo* argumento era SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) el *atributo* argumento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC y el valor en *ValuePtr* era originalmente un identificador de descriptor asignado implícitamente que no sea el identificador asignado a la descartar o APD.|  
|HY024|Valor de atributo no válido|Dada la especificado *atributo* valor, se especificó un valor no válido en *ValuePtr*. (El Administrador de controladores devuelve este SQLSTATE solo para la conexión y los atributos de instrucción que aceptan un conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Para el resto de conexión y los atributos de instrucción, el controlador debe comprobar el valor especificado en *ValuePtr*.)<br /><br /> El *atributo* argumento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, y *ValuePtr* era un identificador de descriptor asignado explícitamente que no está en la misma conexión que el  *StatementHandle* argumento.|  
|HY090|Longitud de búfer o cadena no válida|(DM)  *\*ValuePtr* es una cadena de caracteres y el *StringLength* argumento era menor que 0 pero no era SQL_NTS.|  
|HY092|Identificador de opción o atributo no válido|(DM) el valor especificado para el argumento *atributo* no era válido para la versión de ODBC compatible con el controlador.<br /><br /> (DM) el valor especificado para el argumento *atributo* era un atributo de sólo lectura.|  
|HY117|Conexión está suspendida debido al estado de transacción desconocido. Solo se desconecte y se permiten funciones de solo lectura.|(DM) para obtener más información sobre el estado suspendido, consulte [función SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Característica opcional no implementada|El valor especificado para el argumento *atributo* era un atributo de instrucción ODBC válido para la versión de ODBC compatibles con el controlador, pero no es compatible con el controlador.<br /><br /> El *atributo* argumento era SQL_ATTR_ASYNC_ENABLE y una llamada a **SQLGetInfo** con un *InfoType* de SQL_ASYNC_MODE devuelve SQL_AM_CONNECTION.<br /><br /> El *atributo* argumento era SQL_ATTR_ENABLE_AUTO_IPD y el valor del atributo de conexión SQL_ATTR_AUTO_IPD era SQL_FALSE.|  
|HYT01|Tiempo de espera de conexión agotado|Ha expirado el período de tiempo de espera de conexión antes de que el origen de datos que respondió a la solicitud. El período de tiempo de espera de conexión se establece a través de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Controlador no admite esta función|(DM) el controlador asociado con el *StatementHandle* no admite la función.|  
|S1118|Controlador no admite la notificación asincrónica|Si una llamada a **SQLSetStmtAttr** establecer SQL_ATTR_ASYNC_STMT_EVENT; notificación asincrónica no es compatible con el controlador.|  
  
## <a name="comments"></a>Comentarios  
 Atributos de instrucción para una instrucción sigue surtiendo efecto hasta que se cambian por otra llamada a **SQLSetStmtAttr** o hasta que la instrucción se quita mediante una llamada a **SQLFreeHandle**. Una llamada a **SQLFreeStmt** con el SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS opción no restablece los atributos de instrucción.  
  
 Algunos atributos de instrucción admiten la sustitución de un valor similar si el origen de datos no es compatible con el valor especificado en *ValuePtr*. En tales casos, el controlador devuelve SQL_SUCCESS_WITH_INFO y SQLSTATE 01S02 de SQLState (valor de opción cambiado). Por ejemplo, si *atributo* es SQL_ATTR_CONCURRENCY y *ValuePtr* es SQL_CONCUR_ROWVER, y si el origen de datos no es compatible con esto, el controlador sustituye SQL_CONCUR_VALUES y devuelve SQL_ SUCCESS_WITH_INFO. Para determinar el valor sustituido, una aplicación llama a **SQLGetStmtAttr**.  
  
 Establece el formato de información con *ValuePtr* depende especificado *atributo*. **SQLSetStmtAttr** acepta información de atributo en uno de los dos formatos diferentes: una cadena de caracteres o un valor entero. El formato de cada uno se indica en la descripción del atributo. Este formato se aplica a la información devuelta para cada atributo de **SQLGetStmtAttr**. Caracteres de cadenas que apunta el *ValuePtr* argumento de **SQLSetStmtAttr** tener una longitud de *StringLength*.  
  
> [!NOTE]
>  La capacidad de establecer los atributos de instrucción en el nivel de conexión mediante una llamada a **SQLSetConnectAttr** ha quedado obsoleto en ODBC *3.x*. ODBC *3.x* aplicaciones nunca deben establecer los atributos de instrucción en el nivel de conexión. ODBC *3.x* atributos de instrucción no se puede establecer en el nivel de conexión, a excepción de los atributos SQL_ATTR_METADATA_ID y SQL_ATTR_ASYNC_ENABLE, que son los atributos de conexión y los atributos de instrucción y pueden ser establecer en el nivel de conexión o el nivel de instrucción.  
> 
> [!NOTE]
>  ODBC *3.x* controladores sólo necesitan admitir esta funcionalidad si trabajan con ODBC *2.x* aplicaciones que establezcan ODBC *2.x* opciones de la instrucción en el nivel de conexión. Para obtener más información, consulte "Configuración de opciones en la conexión de nivel de instrucción" en [asignación de SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) en Apéndice G: Directrices de controlador para la compatibilidad con versiones anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrucción que establece los campos de Descriptor  
 Muchos de los atributos de instrucción corresponden a un campo de encabezado de un descriptor. Establecer estos atributos realmente los resultados en la configuración de los campos de descriptor. Establecer campos mediante una llamada a **SQLSetStmtAttr** en lugar de a **SQLSetDescField** tiene la ventaja de que no tiene un identificador de descriptor que obtenerse de la llamada de función.  
  
> [!CAUTION]  
>  Una llamada a **SQLSetStmtAttr** para una instrucción puede afectar a otras instrucciones. Esto ocurre cuando el APD o descartar asociados con la instrucción se asigna explícitamente y también está asociado con otras instrucciones. Dado que **SQLSetStmtAttr** modifica el APD o descartar, las modificaciones se aplican a todas las instrucciones que está asociada este descriptor. Si esto no es el comportamiento necesario, la aplicación debe desasociar este descriptor de las demás instrucciones (mediante una llamada a **SQLSetStmtAttr** para establecer el campo SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC a otro identificador de descriptor) antes de llamar a **SQLSetStmtAttr** nuevo.  
  
 Cuando un campo descriptor se establece como resultado que se va a establecer el atributo de instrucción correspondiente, el campo se establece solo para los descriptores de aplicable que están asociados actualmente con la instrucción identificada por el *StatementHandle* argumento y el valor de atributo no afecta a los descriptores que pueden estar asociados a esa instrucción en el futuro. Cuando un campo de descriptor que también es un atributo de instrucción se establece mediante una llamada a **SQLSetDescField**, se establece el atributo de instrucción correspondiente. Si un descriptor asignado explícitamente se desasocia de una instrucción, un atributo de instrucción que se corresponde con un campo de encabezado se restablecerá al valor del campo en el descriptor implícitamente asignado.  
  
 Cuando se asigna una instrucción (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), cuatro identificadores de descriptor automáticamente asignados y asociados con la instrucción. Identificadores de descriptor asignado explícitamente se pueden asociadas con la instrucción mediante una llamada a **SQLAllocHandle** con un *fHandleType* de SQL_HANDLE_DESC para asignar un identificador de descriptor y, a continuación, llamar a  **SQLSetStmtAttr** para asociar el identificador de descriptor de la instrucción.  
  
 Los atributos de instrucción en la tabla siguiente corresponden a los campos de encabezado de descriptor.  
  
|atributo de instrucción|Campo de encabezado|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|DESCARTAR|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|DESCARTAR|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|DESCARTAR|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|DESCARTAR|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrucción  
 Se muestran los atributos definidos actualmente y la versión de ODBC en el que se presentaron en la siguiente tabla. se espera que se definirá más atributos por los controladores para aprovechar las ventajas de diferentes orígenes de datos. Un intervalo de atributos está reservado por ODBC; los desarrolladores de controladores deben reservar los valores para su propio uso específico del controlador de Open Group. Para obtener más información, consulte [los tipos de datos específicos del controlador, Descriptor tipos, tipos de información, tipos de diagnóstico y atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Atributo|*ValuePtr* contenido|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|El identificador para el APD para las llamadas subsiguientes a **SQLExecute** y **SQLExecDirect** en el identificador de instrucción. El valor inicial de este atributo es el descriptor que se asignan implícitamente cuando la instrucción se asignó inicialmente. Si el valor de este atributo se establece en SQL_NULL_DESC o el identificador se asignó originalmente para el descriptor, se desasocia un identificador APD explícitamente asignado que asoció anteriormente con el identificador de instrucción de él y el identificador de instrucción vuelve a la asigna implícitamente identificador APD.<br /><br /> No se puede establecer este atributo a un identificador de descriptor que implícitamente se asignó a otra instrucción o a otro identificador de descriptor que se establece implícitamente en la misma instrucción; no se puede asociadas con más de una instrucción o el identificador de descriptor de identificadores de descriptores implícitamente asignados.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|El identificador de la Descartar para recuperaciones posteriores en el identificador de instrucción. El valor inicial de este atributo es el descriptor que se asignan implícitamente cuando la instrucción se asignó inicialmente. Si el valor de este atributo se establece en SQL_NULL_DESC o el identificador se asignó originalmente para el descriptor, se desasocia un identificador de descartar explícitamente asignado que asoció anteriormente con el identificador de instrucción de él y el identificador de instrucción vuelve a la asigna implícitamente identificador descartar.<br /><br /> No se puede establecer este atributo a un identificador de descriptor que implícitamente se asignó a otra instrucción o a otro identificador de descriptor que se establece implícitamente en la misma instrucción; no se puede asociadas con más de una instrucción o el identificador de descriptor de identificadores de descriptores implícitamente asignados.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Un valor SQLULEN que especifica si llama una función con la instrucción especificada se ejecuta de forma asincrónica:<br /><br /> SQL_ASYNC_ENABLE_OFF = deshabilitar compatibilidad de nivel de ejecución asincrónica las instrucciones (valor predeterminado).<br /><br /> SQL_ASYNC_ENABLE_ON = Habilitar soporte de nivel de ejecución asincrónica de instrucción.<br /><br /> Para obtener más información, consulte [ejecución asincrónica (método de sondeo)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para los controladores con el soporte técnico de nivel de ejecución asincrónica de instrucción, el atributo de instrucción SQL_ATTR_ASYNC_ENABLE es de solo lectura. Su valor es igual que el valor del atributo de nivel de conexión con el mismo nombre en el momento en que se ha asignado el identificador de instrucción.<br /><br /> Una llamada a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_ENABLE cuando la SQL_ASYNC_MODE *InfoType* devuelve SQL_AM_CONNECTION devuelve SQLSTATE HYC00 (característica opcional no implementada). Para obtener más información, consulte [función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obtener más información.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Un valor SQLPOINTER que es un identificador de evento.<br /><br /> Está habilitada la notificación de finalización de las funciones asincrónicas mediante una llamada a **SQLSetStmtAttr** para establecer el **SQL_ATTR_ASYNC_STMT_EVENT** atributo y especifique el identificador de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER a la función de devolución de llamada asincrónica.<br /><br /> Solo el Administrador de controladores puede llamar a un controlador **SQLSetStmtAttr** función con este atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER a la estructura de contexto<br /><br /> Solo el Administrador de controladores puede llamar a un controlador **SQLSetStmtAttr** función con este atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Un valor SQLULEN que especifica la simultaneidad de cursor:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor es de solo lectura. No se permiten actualizaciones.<br /><br /> SQL_CONCUR_LOCK = Cursor usará el nivel más bajo de bloqueo suficiente para asegurarse de que se puede actualizar la fila.<br /><br /> SQL_CONCUR_ROWVER = Cursor utiliza control de simultaneidad optimista, comparar las versiones de fila como SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor utiliza control de simultaneidad optimista, comparación de valores.<br /><br /> El valor predeterminado de SQL_ATTR_CONCURRENCY es SQL_CONCUR_READ_ONLY.<br /><br /> No se puede especificar este atributo para un cursor abierto. Para obtener más información, consulte [tipos de simultaneidad](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si el SQL_ATTR_CURSOR_TYPE *atributo* se cambia a un tipo que no es compatible con el valor actual de SQL_ATTR_CONCURRENCY, se cambiará el valor de SQL_ATTR_CONCURRENCY en tiempo de ejecución y emite una advertencia cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si el controlador admite la **SELECT FOR UPDATE** instrucción y dicha instrucción se ejecuta mientras se establece el valor de SQL_ATTR_CONCURRENCY en SQL_CONCUR_READ_ONLY, se devolverá un error. Si se cambia el valor de SQL_ATTR_CONCURRENCY a un valor que admite el controlador para algún valor de SQL_ATTR_CURSOR_TYPE pero no para el valor actual de SQL_ATTR_CURSOR_TYPE, se cambiará el valor de SQL_ATTR_CURSOR_TYPE en tiempo de ejecución y 01S02 de SQLSTATE SQLSTATE (Valor de opción cambiado) se emite cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si la simultaneidad especificada no es compatible con el origen de datos, el controlador sustituye una simultaneidad diferente y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado). Para SQL_CONCUR_VALUES, el controlador sustituye SQL_CONCUR_ROWVER y viceversa. Para SQL_CONCUR_LOCK, el controlador sustituye, en orden, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. No se comprueba la validez del valor sustituido hasta el tiempo de ejecución.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CONCURRENCY y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Un valor SQLULEN que especifica el nivel de compatibilidad que necesita la aplicación. Al establecer este atributo afecta a las llamadas subsiguientes a **SQLExecDirect** y **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable cursores no son obligatorios en el identificador de instrucción. Si la aplicación llama a **SQLFetchScroll** en este identificador, el único valor válido de *FetchOrientation* es SQL_FETCH_NEXT. Ésta es la opción predeterminada.<br /><br /> SQL_SCROLLABLE = Scrollable cursores son necesarios en el identificador de instrucción. Al llamar a **SQLFetchScroll**, la aplicación puede especificar cualquier valor válido de *FetchOrientation*, lograr el posicionamiento de cursor en modos que no sea el modo secuencial.<br /><br /> Para obtener más información acerca de los cursores desplazables, consulte [los cursores desplazables](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SCROLLABLE y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un valor SQLULEN que especifica si los cursores en el identificador de instrucción hacer visibles los cambios realizados en un resultado establecen por otro cursor. Al establecer este atributo afecta a las llamadas subsiguientes a **SQLExecDirect** y **SQLExecute**. Una aplicación puede leer de nuevo el valor de este atributo para obtener su estado inicial o su estado como más recientemente establecido por la aplicación.<br /><br /> SQL_UNSPECIFIED = no se especifica el tipo de cursor y si la cursores en el identificador de instrucción hacer visibles los cambios realizados en un conjunto de resultados por otro cursor. Los cursores en el identificador de instrucción pueden hacer visible ninguno, algunos o todos los cambios. Ésta es la opción predeterminada.<br /><br /> SQL_INSENSITIVE = todos los cursores de la presentación de identificador de instrucción, el conjunto de resultados sin reflejar los cambios realizados en él por cualquier otro cursor. Los cursores INSENSITIVE son de solo lectura. Esto corresponde a un cursor estático, que tiene una simultaneidad que es de solo lectura.<br /><br /> SQL_SENSITIVE = todos los cursores de la marca de identificador de instrucción que visibles todos los cambios realizados en un valor establecidos por otro cursor.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SENSITIVITY y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Un valor SQLULEN que especifica el tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = el cursor solo se desplaza hacia delante.<br /><br /> SQL_CURSOR_STATIC = los datos en el resultado de conjunto es estático.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = el controlador de guarda y usa las claves para el número de filas especificado en el atributo de instrucción SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = el controlador de guarda y usa sólo las claves para las filas del conjunto de filas.<br /><br /> El valor predeterminado es SQL_CURSOR_FORWARD_ONLY. Este atributo no se puede especificar una vez se ha preparado la instrucción SQL.<br /><br /> Si el tipo de cursor especificado no es compatible con el origen de datos, el controlador sustituye un tipo de cursor diferente y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado). Para un cursor dinámico o mixto, el controlador sustituye, en orden, un cursor controlado por conjunto de claves o estático. Para un cursor controlado por conjunto de claves, el controlador sustituye un cursor estático.<br /><br /> Para obtener más información acerca de los tipos de cursor desplazable, consulte [tipos de Cursor desplazable](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_TYPE y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Un valor SQLULEN que especifica si se realiza un rellenado automático de la IPD:<br /><br /> SQL_TRUE = activa en el rellenado automático de la IPD después de llamar a **SQLPrepare**. SQL_FALSE = vueltas desactivar el rellenado automático de la IPD después de llamar a **SQLPrepare**. (Una aplicación todavía puede obtener información de los campos IPD mediante una llamada a **SQLDescribeParam**, si se admite.) El valor predeterminado del atributo de instrucción SQL_ATTR_ENABLE_AUTO_IPD es SQL_FALSE. Para obtener más información, consulte [rellenado automático de la IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* que apunta a un valor binario de marcador. Cuando **SQLFetchScroll** se llama con *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, el controlador recoge el valor de marcador de este campo. El valor predeterminado de este campo es un puntero nulo. Para obtener más información, consulte [desplazamiento por marcador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> El valor al que señala este campo no se utiliza para eliminar por marcador, actualizar por marcador o capturar las operaciones de marcador de **SQLBulkOperations**, que utilice marcadores almacenados en caché en los búferes del conjunto de filas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|El identificador de la IPD. El valor de este atributo es el descriptor asignado cuando la instrucción se asignó inicialmente. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|El identificador de IRD. El valor de este atributo es el descriptor asignado cuando la instrucción se asignó inicialmente. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Un SQLULEN que especifica el número de filas del conjunto de claves para un cursor dinámico. Si el tamaño del conjunto de claves es 0 (valor predeterminado), el cursor está totalmente controlado por conjunto de claves. Si el tamaño del conjunto de claves es mayor que 0, el cursor es mixto (controlado por conjunto de claves en el conjunto de claves y dinámicos fuera el conjunto de claves). El tamaño del conjunto de claves predeterminado es 0. Para obtener más información acerca de los cursores dinámicos, consulte [cursores](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si el tamaño especificado supera el tamaño máximo del conjunto de claves, el controlador sustituye ese tamaño y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado).<br /><br /> **SQLFetch** o **SQLFetchScroll** devuelve un error si el tamaño del conjunto de claves es mayor que 0 y menor que el tamaño del conjunto de filas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Un valor SQLULEN que especifica la cantidad máxima de datos que devuelve el controlador de un carácter o una columna binaria. Si *ValuePtr* es menor que la longitud de los datos disponibles, **SQLFetch** o **SQLGetData** trunca los datos y devuelve SQL_SUCCESS. Si *ValuePtr* es 0 (valor predeterminado), el controlador intenta devolver todos los datos disponibles.<br /><br /> Si la longitud especificada es menor que la cantidad mínima de los datos que puede devolver el origen de datos o mayor que la cantidad máxima de datos que puede devolver el origen de datos, los sustitutos de controlador que valoran y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 de SQLState (valor de opción cambiado) y restablece el atributo a su valor original.<br /><br /> Este atributo está pensado para reducir el tráfico de red y debe ser compatible sólo cuando el origen de datos (en lugar del controlador) en un controlador de varios niveles puede implementarla. Este mecanismo no debe usarse con las aplicaciones para truncar los datos; para truncar los datos recibidos, una aplicación debe especificar la longitud máxima del búfer en el *BufferLength* argumento en **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Un valor SQLULEN corresponde al número máximo de filas que se va a devolver a la aplicación para un **seleccione** instrucción. Si \* *ValuePtr* es igual a 0 (valor predeterminado), el controlador devuelve todas las filas.<br /><br /> Este atributo está pensado para reducir el tráfico de red. Conceptualmente, se aplica cuando el conjunto de resultados se crea y limita el conjunto de resultados a la primera *ValuePtr* filas. Si es mayor que el número de filas del conjunto de resultados *ValuePtr*, se trunca el conjunto de resultados.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos los conjuntos de resultados en el *instrucción*, los devueltos por las funciones de catálogo incluidos. SQL_ATTR_MAX_ROWS establece un máximo para el valor de recuento de filas de cursor.<br /><br /> Un controlador no debe emular el comportamiento SQL_ATTR_MAX_ROWS para **SQLFetch** o **SQLFetchScroll** (si las limitaciones de tamaño del conjunto de resultados no se puede implementar en el origen de datos) si no puede garantizar que SQL_ATTR_ MAX_ROWS se implementará correctamente.<br /><br /> Es definido por el controlador si SQL_ATTR_MAX_ROWS se aplica a las instrucciones que no sean las instrucciones SELECT (por ejemplo, las funciones de catálogo).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 de SQLState (valor de opción cambiado) y restablece el atributo a su valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Un valor SQLULEN que determina cómo se tratan los argumentos de cadena de funciones de catálogo.<br /><br /> Si el valor SQL_TRUE, el argumento de cadena de funciones de catálogo se tratan como identificadores. El caso no es significativo. Para las cadenas sin delimitar, el controlador quita los espacios finales y se dobla la cadena a mayúsculas. Para las cadenas delimitadas, el controlador quita los espacios iniciales o finales y toma todo lo que es entre los delimitadores literalmente. Si uno de estos argumentos se establece en un puntero nulo, la función devuelve SQL_ERROR y SQLSTATE HY009 (uso no válido del puntero nulo).<br /><br /> Si SQL_FALSE, los argumentos de cadena de funciones de catálogo no se tratan como identificadores. El caso es significativo. O bien pueden contener un patrón de búsqueda de cadena o no, dependiendo del argumento.<br /><br /> El valor predeterminado es SQL_FALSE.<br /><br /> El *TableType* argumento de **SQLTables**, que toma una lista de valores, no se ve afectada por este atributo.<br /><br /> SQL_ATTR_METADATA_ID también se puede establecer en el nivel de conexión. (Lo que SQL_ATTR_ASYNC_ENABLE son los atributos de instrucción única que también son los atributos de conexión).<br /><br /> Para obtener más información, consulte [argumentos en funciones de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Un valor SQLULEN que indica si el controlador debe buscar cadenas SQL para las secuencias de escape:<br /><br /> SQL_NOSCAN_OFF = las exploraciones de controlador cadenas SQL para las secuencias de escape (valor predeterminado).<br /><br /> SQL_NOSCAN_ON = el controlador no analiza las cadenas de SQL para las secuencias de escape. En su lugar, el controlador envía la instrucción directamente al origen de datos.<br /><br /> Para obtener más información, consulte [secuencias de Escape de ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valor al que apunta a un desplazamiento que se agregan a los punteros a cambiar el enlace de parámetros dinámicos. Si este campo es distinto de null, el controlador desreferencia el puntero, agrega el valor sin referencia a cada uno de los campos aplazados del registro de descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y usa los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> El desplazamiento de enlace siempre se agrega directamente a los campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR. Si el desplazamiento se cambia a un valor diferente, el nuevo valor todavía se agrega directamente al valor en el campo descriptor. El desplazamiento nuevo no se agrega al valor del campo más los desplazamientos anteriores.<br /><br /> Para obtener más información, consulte [desplazamientos de enlace de parámetro](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Un valor SQLULEN que indica la orientación de enlace que se usará para los parámetros dinámicos.<br /><br /> Este campo se establece en SQL_PARAM_BIND_BY_COLUMN (valor predeterminado) para seleccionar el enlace.<br /><br /> Para seleccionar el enlace, este campo se establece en la longitud de la estructura o una instancia de un búfer que se enlazará a un conjunto de parámetros dinámicos. Esta longitud debe incluir el espacio para todos los parámetros enlazados y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de un parámetro dependiente se incrementa con la longitud especificada, el resultado señalará al principio del mismo parámetro en los próximos conjunto de parámetros. Cuando se usa el *sizeof* operador en ANSI C, se garantiza que este comportamiento.<br /><br /> Para obtener más información, consulte [enlazar las matrices de parámetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ BIND_TYPE en el encabezado APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor al que apunta a una matriz de valores SQLUSMALLINT se usa para omitir un parámetro durante la ejecución de una instrucción SQL. Cada valor se establece en SQL_PARAM_PROCEED (para el parámetro que se va a ejecutar) o SQL_PARAM_IGNORE (para el parámetro se pasará por alto).<br /><br /> Un conjunto de parámetros puede omitirse durante el procesamiento estableciendo el valor de estado de la matriz señalada por SQL_DESC_ARRAY_STATUS_PTR en el APD a SQL_PARAM_IGNORE. Si su valor de estado se establece en SQL_PARAM_PROCEED o si no hay elementos de la matriz se establecen, se procesa un conjunto de parámetros.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve parámetros valores de estado. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLExecDirect** o **SQLExecute** se llama.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* que contiene información de estado para cada fila de valores de parámetro después de llamar a los valores de valor al que apunta a una matriz de SQLUSMALLINT **SQLExecute** o **SQLExecDirect**. Este campo es obligatorio solo si PARAMSET_SIZE es mayor que 1.<br /><br /> Los valores de estado pueden contener los siguientes valores:<br /><br /> SQL_PARAM_SUCCESS: La instrucción SQL se ha ejecutado correctamente para este conjunto de parámetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Se ha ejecutado correctamente la instrucción SQL para este conjunto de parámetros; Sin embargo, hay información de advertencia en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Se produjo un error en el procesamiento de este conjunto de parámetros. Información de error adicional está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Este conjunto de parámetros estaba sin usar, posiblemente debido al hecho de que algún conjunto de parámetros anterior ha causado un error que se anuló el procesamiento posterior, o porque se estableció SQL_PARAM_IGNORE para ese conjunto de parámetros de la matriz especificada por el SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: El controlador trata a las matrices de parámetros como una unidad monolítica y no genera este nivel de información de error.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve parámetros valores de estado. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLExecute** o **SQLExecDirect** se llama. Observe que al establecer este atributo puede afectar el comportamiento del parámetro de salida implementado por el controlador.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* campos de registros que apunta a un búfer en el que se va a devolver el número de conjuntos de parámetros que se han procesado, incluidos los conjuntos de error. Si se trata de un puntero nulo, no se devolverá ningún número.<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IPD.<br /><br /> Si la llamada a **SQLExecDirect** o **SQLExecute** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de valores para cada parámetro. Si SQL_ATTR_PARAMSET_SIZE es mayor que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR del punto APD a las matrices. La cardinalidad de cada matriz es igual al valor de este campo.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_SIZE en el encabezado APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Un valor SQLULEN corresponde al número de segundos de espera para que una instrucción SQL se ejecute antes de volver a la aplicación. Si *ValuePtr* es igual a 0 (valor predeterminado), no hay ningún tiempo de espera.<br /><br /> Si el tiempo de espera especificado supera el tiempo de espera máximo en el origen de datos o es menor que el tiempo de espera mínimo **SQLSetStmtAttr** sustituye ese valor y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado).<br /><br /> Tenga en cuenta que la aplicación no necesita llamar a **SQLCloseCursor** para volver a usar la instrucción si un **seleccione** instrucción agotó el tiempo de espera.<br /><br /> El tiempo de espera de consulta establecido en este atributo de instrucción es válida en los modos sincrónico y asincrónico.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valor SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** y, en ODBC *3.x*, **SQLFetch** recuperar los datos después de que coloca el cursor a la ubicación especificada. Ésta es la opción predeterminada.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** y, en ODBC *3.x*, **SQLFetch** no recuperar los datos después de que coloca el cursor.<br /><br /> Al establecer SQL_RETRIEVE_DATA en SQL_RD_OFF, una aplicación puede comprobar que existe una fila o de recuperar un marcador para la fila sin incurrir en la sobrecarga que supone recuperar filas. Para obtener más información, consulte [desplazamiento y captura filas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 de SQLState (valor de opción cambiado) y restablece el atributo a su valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de filas devueltas por cada llamada a **SQLFetch** o **SQLFetchScroll**. También es el número de filas en una matriz de marcador que se utiliza en una operación de marcador de forma masiva en **SQLBulkOperations**. El valor predeterminado es 1.<br /><br /> Si el tamaño del conjunto de filas especificado supera el tamaño de conjunto de filas máximo admitido por el origen de datos, el controlador sustituye ese valor y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado).<br /><br /> Para obtener más información, consulte [tamaño del conjunto de filas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_SIZE en el encabezado de descartar.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valor al que apunta a un desplazamiento que se agregan a los punteros a cambiar el enlace de datos de columna. Si este campo es distinto de null, el controlador desreferencia el puntero, agrega el valor sin referencia a cada uno de los campos aplazados del registro de descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y usa los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado de descartar.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Un valor SQLULEN que establece la orientación de enlace que se usará al **SQLFetch** o **SQLFetchScroll** se llama en la instrucción asociada. El enlace se selecciona estableciendo el valor en SQL_BIND_BY_COLUMN. El enlace se selecciona estableciendo el valor para la longitud de una estructura o una instancia de un búfer en el que se enlazará columnas de resultados.<br /><br /> Si se especifica una longitud, debe incluir el espacio para todas las columnas enlazadas y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de una columna enlazada se incrementa con la longitud especificada, el resultado señalará al principio de la misma columna en th fila siguiente de e. Cuando se usa el **sizeof** operador con estructuras o uniones en ANSI C, se garantiza que este comportamiento.<br /><br /> El enlace es la orientación de enlace predeterminada para **SQLFetch** y **SQLFetchScroll**.<br /><br /> Para obtener más información, consulte [enlazar columnas para su uso con cursores de bloque](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_TYPE en el encabezado de descartar.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Establece un valor SQLULEN que es el número de la fila actual en todo el resultado. Si no se puede determinar el número de la fila actual o no hay ninguna fila, el controlador devuelve 0.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor al que apunta a una matriz de valores SQLUSMALLINT se usa para omitir una fila durante una operación masiva mediante **SQLSetPos**. Cada valor se establece en SQL_ROW_PROCEED (para la fila que se incluirán en la operación masiva) o SQL_ROW_IGNORE (para la fila que desea excluir de la operación masiva). (No se pueden omitir las filas mediante el uso de esta matriz durante las llamadas a **SQLBulkOperations**.)<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve los valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLSetPos** se llama.<br /><br /> Para obtener más información, consulte [actualizar filas en el conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) y [eliminar filas del conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR el descartar.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor que apunta a una matriz de SQLUSMALLINT valores que contengan valores de estado de fila después de llamar a **SQLFetch** o **SQLFetchScroll**. La matriz tiene tantos elementos como filas en el conjunto de filas.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve los valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, o  **SQLSetPos** se llama.<br /><br /> Para obtener más información, consulte [estado y número de filas recuperado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IRD.<br /><br /> Este atributo se asigna un ODBC *2.x* controlador para el *rgbRowStatus* matriz en una llamada a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* valor al que apunta a un búfer en el que se va a devolver el número de filas recuperadas después de llamar a **SQLFetch** o **SQLFetchScroll**; el número de filas afectadas por una operación masiva realizadas mediante una llamada a **SQLSetPos** con un *operación* argumento de SQL_REFRESH; o el número de filas afectadas por una operación masiva realizada por **SQLBulkOperations**. Este número incluye las filas de error.<br /><br /> Para obtener más información, consulte [estado y número de filas recuperado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IRD.<br /><br /> Si la llamada a **SQLFetch** o **SQLFetchScroll** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Un valor SQLULEN que especifica si los controladores que simulan colocados instrucciones update y delete garantiza que estas instrucciones afectan a solo una sola fila.<br /><br /> Para simular la actualización posicionada e instrucciones delete, la mayoría de los controladores construir una búsqueda **actualizar** o **eliminar** instrucción que contiene un **donde** cláusula que especifica el valor de cada columna en la fila actual. A menos que estas columnas componen una clave única, dicha instrucción puede afectar a más de una fila.<br /><br /> Para garantizar que estas instrucciones afectan a una única fila, el controlador determina las columnas de una clave única y agrega estas columnas al conjunto de resultados. Si una aplicación garantiza que las columnas del conjunto de resultados constituyen una clave única, el controlador no es necesario hacerlo. Esto puede reducir el tiempo de ejecución.<br /><br /> SQL_SC_NON_UNIQUE = el controlador garantiza que simula actualización por posición o las instrucciones delete afectarán a una única fila; es responsabilidad de la aplicación que lo haga. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de operación de Cursor).<br /><br /> SQL_SC_TRY_UNIQUE = el controlador intenta garantizar que simula actualización por posición o eliminar instrucciones afectan a una única fila. El controlador siempre ejecuta estas instrucciones, aunque es posible que afectan a más de una fila, por ejemplo, cuando no hay ninguna clave única. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de operación de Cursor).<br /><br /> SQL_SC_UNIQUE = las garantías de controlador que simula la actualización por posición o eliminar instrucciones afectan a una única fila. Si el controlador no puede garantizar en una instrucción determinada, **SQLExecDirect** o **SQLPrepare** devuelve un error.<br /><br /> Si el origen de datos proporciona SQL nativo compatibilidad con actualización posicionada y eliminar las instrucciones y el controlador no simula los cursores, se devuelve SQL_SUCCESS cuando se solicitan SQL_SC_UNIQUE SQL_SIMULATE_CURSOR. Si se solicita SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE, se devuelve SQL_SUCCESS_WITH_INFO. Si el origen de datos proporciona el nivel SQL_SC_TRY_UNIQUE de soporte técnico y el controlador no lo hace, se devuelve SQL_SUCCESS para SQL_SC_TRY_UNIQUE y SQL_SUCCESS_WITH_INFO se devuelve para SQL_SC_NON_UNIQUE.<br /><br /> Si el tipo de simulación de cursor especificado no es compatible con el origen de datos, el controlador sustituye un tipo diferente de simulación y devuelve SQLSTATE 01S02 de SQLState (valor de opción cambiado). Para SQL_SC_UNIQUE, el controlador sustituye, en orden, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Para SQL_SC_TRY_UNIQUE, el controlador sustituye SQL_SC_NON_UNIQUE.<br /><br /> El valor predeterminado es SQL_SC_UNIQUE.<br /><br /> Para obtener más información, consulte [simulación de actualización coloca y eliminar instrucciones](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Un valor SQLULEN que especifica si una aplicación usará los marcadores con un cursor:<br /><br /> SQL_UB_OFF = Off (valor predeterminado)<br /><br /> SQL_UB_VARIABLE = utilizará la aplicación marcadores con un cursor y el controlador proporcionará los marcadores de longitud variable si son compatibles. SQL_UB_FIXED está en desuso en ODBC *3.x*. ODBC *3.x* las aplicaciones siempre deben usar marcadores de longitud variable, incluso cuando se trabaja con ODBC *2.x* controladores (que admiten marcadores sólo 4 bytes, de longitud fija). Esto es porque un marcador de longitud fija es simplemente un caso especial de un marcador de longitud variable. Cuando se trabaja con un ODBC *2.x* controlador, el Administrador de controladores asigna SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Para utilizar marcadores con un cursor, la aplicación debe especificar este atributo con el valor SQL_UB_VARIABLE antes de abrir el cursor.<br /><br /> Para obtener más información, consulte [recuperar marcadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] estas funciones se pueden llamar de forma asincrónica solo si el descriptor es un descriptor de implementación, no un descriptor de la aplicación.  
  
 Consulte [el enlace](../../../odbc/reference/develop-app/column-wise-binding.md) y [el enlace](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funciones relacionadas  
  
|Para obtener información acerca de|Vea|  
|---------------------------|---------|  
|Procesamiento de una instrucción de cancelación|[Función SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Devuelve el valor de un atributo de conexión|[Función SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Devuelve la configuración de un atributo de instrucción|[Función SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Establecer un atributo de conexión|[Función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Configuración de un campo único del descriptor|[Función SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vea también  
 [Referencia de la API de ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Archivos de encabezado de ODBC](../../../odbc/reference/install/odbc-header-files.md)
