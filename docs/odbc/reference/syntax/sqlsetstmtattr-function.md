---
title: Función SQLSetStmtAttr ? Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287274"
---
# <a name="sqlsetstmtattr-function"></a>Función SQLSetStmtAttr
**Conformidad**  
 Versión introducida: Cumplimiento de normas ODBC 3.0: ISO 92  
  
 **Resumen**  
 **SQLSetStmtAttr** establece atributos relacionados con una instrucción.  
  
> [!NOTE]
>  Para obtener más información acerca de a qué asigna el Administrador de controladores esta función cuando una aplicación ODBC *3.x* está trabajando con un controlador ODBC *2.x,* vea Asignación de funciones de [reemplazo para la compatibilidad con versiones anteriores de aplicaciones](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxis  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Identificador de instrucción.  
  
 *Atributo*  
 [Entrada] Opción para establecer, listada en "Comentarios."  
  
 *ValuePtr*  
 [Entrada] Valor que se asociará con *Atributo*. Dependiendo del valor de *Attribute*, *ValuePtr* será uno de los siguientes:  
  
-   Un identificador de descriptor ODBC.  
  
-   Un valor SQLUINTEGER.  
  
-   Un valor SQLULEN.  
  
-   Un puntero a una de las siguientes opciones:  
  
    -   Una cadena de caracteres terminada en null.  
  
    -   Un búfer binario.  
  
    -   Valor o matriz de tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valor definido por el controlador.  
  
 Si el *atributo* argumento es un valor específico del controlador, *ValuePtr* puede ser un entero con signo.  
  
 *StringLength*  
 [Entrada] Si *Attribute* es un atributo definido por ODBC y *ValuePtr* apunta a una cadena \*de caracteres o un búfer binario, este argumento debe ser la longitud de *ValuePtr*. Si *Attribute* es un atributo definido por ODBC y *ValuePtr* es un entero, *StringLength* se omite.  
  
 Si *Attribute* es un atributo definido por el controlador, la aplicación indica la naturaleza del atributo para el Administrador de controladores estableciendo el *StringLength* argumento. *StringLength* puede tener los siguientes valores:  
  
-   Si *ValuePtr* es un puntero a una cadena de caracteres, *StringLength* es la longitud de la cadena o SQL_NTS.  
  
-   Si *ValuePtr* es un puntero a un búfer binario, la aplicación coloca el resultado de la macro SQL_LEN_BINARY_ATTR(*length*) en *StringLength*. Esto coloca un valor negativo en *StringLength*.  
  
-   Si *ValuePtr* es un puntero a un valor distinto de una cadena de caracteres o una cadena binaria, *StringLength* debe tener el valor SQL_IS_POINTER.  
  
-   Si *ValuePtr* contiene un valor de longitud fija, *StringLength* es SQL_IS_INTEGER o SQL_IS_UINTEGER, según corresponda.  
  
## <a name="returns"></a>Devuelve  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnóstico  
 Cuando **SQLSetStmtAttr** devuelve SQL_ERROR o SQL_SUCCESS_WITH_INFO, se puede obtener un valor SQLSTATE asociado llamando a **SQLGetDiagRec** con un *HandleType* de SQL_HANDLE_STMT y un *control* de *StatementHandle*. En la tabla siguiente se enumeran los valores SQLSTATE devueltos normalmente por **SQLSetStmtAttr** y se explica cada uno de ellos en el contexto de esta función; la notación "(DM)" precede a las descripciones de SQLSTATEs devueltas por el Administrador de controladores. El código de retorno asociado a cada valor SQLSTATE se SQL_ERROR, a menos que se indique lo contrario.  
  
|SQLSTATE|Error|Descripción|  
|--------------|-----------|-----------------|  
|01000|Advertencia general|Mensaje informativo específico del controlador. (La función devuelve SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valor de opción cambiado|El controlador no admitía el valor especificado en *ValuePtr*, o el valor especificado en *ValuePtr* no era válido debido a las condiciones de trabajo de implementación, por lo que el controlador sustituyó un valor similar. (**SQLGetStmtAttr** se puede llamar para determinar el valor sustituido temporalmente.) El valor sustituto es válido para *StatementHandle* hasta que se cierra el cursor, momento en el que el atributo de instrucción vuelve a su valor anterior. Los atributos de instrucción que se pueden cambiar son:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La función devuelve SQL_SUCCESS_WITH_INFO.)|  
|08S01|Fallo del enlace de comunicación|Error en el vínculo de comunicación entre el controlador y el origen de datos al que estaba conectado el controlador antes de que la función completara el procesamiento.|  
|24000|Estado de cursor no válido|El *atributo* se SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS y el cursor estaba abierto.|  
|HY000|Error general|Se ha producido un error para el que no se ha definido sqlSTATE específico y para el que no se ha definido sqlSTATE específico de la implementación. El mensaje de error devuelto por **SQLGetDiagRec** en el * \*messageText* búfer describe el error y su causa.|  
|HY001|Error de asignación de memoria|El controlador no pudo asignar la memoria necesaria para admitir la ejecución o finalización de la función.|  
|HY009|Uso no válido de puntero nulo|El *attribute* argumento identificó un atributo de instrucción que requería un atributo de cadena y el *ValuePtr* argumento era un puntero nulo.|  
|HY010|Error de secuencia de funciones|(DM) se llamó a una función de ejecución asincrónica para el identificador de conexión asociado a *StatementHandle*. Esta función asincrónica todavía se estaba ejecutando cuando se llamó a la función **SQLSetStmtAttr.**<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**o **SQLMoreResults** se llamó para el *StatementHandle* y devuelto SQL_PARAM_DATA_AVAILABLE. Se llamó a esta función antes de recuperar los datos para todos los parámetros transmitidos.<br /><br /> (DM) se llamó a una función de ejecución asincrónica para el *StatementHandle* y todavía se estaba ejecutando cuando se llamó a esta función.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, o **SQLSetPos** se llamó para el *StatementHandle* y devuelto SQL_NEED_DATA. Se llamó a esta función antes de que se enviaran datos para todos los parámetros o columnas de datos en ejecución.|  
|HY011|Atributo no se puede establecer ahora|El *atributo* se SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, ATTR_SIMULATE_CURSOR SQL_ o ATTR_USE_BOOKMARKS SQL_ y se preparó la instrucción.|  
|HY013|Error de administración de memoria|No se pudo procesar la llamada de función porque no se pudo tener acceso a los objetos de memoria subyacentes, posiblemente debido a condiciones de poca memoria.|  
|HY017|Uso no válido de un identificador de descriptor asignado automáticamente|(DM) El *argumento Attribute* fue SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) el *attribute* argumento se SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, y el valor en *ValuePtr* era un identificador de descriptor asignado implícitamente que no sea el identificador asignado originalmente para el ARD o APD.|  
|HY024|Valor de atributo no válido|Dado el valor *Attribute* especificado, se especificó un valor no válido en *ValuePtr*. (El Administrador de controladores devuelve este SQLSTATE solo para los atributos de conexión e instrucción que aceptan un conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Para todos los demás atributos de conexión e instrucción, el controlador debe comprobar el valor especificado en *ValuePtr*.)<br /><br /> El *Attribute* argumento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, y *ValuePtr* era un identificador de descriptor asignado explícitamente que no está en la misma conexión que el *StatementHandle* argumento.|  
|HY090|Cadena no válida o longitud de búfer|(DM) * \*ValuePtr* es una cadena de caracteres y el *StringLength* argumento era menor que 0 pero no se SQL_NTS.|  
|HY092|Identificador de atributo/opción no válido|(DM) el valor especificado para el argumento *Attribute* no era válido para la versión de ODBC admitida por el controlador.<br /><br /> (DM) el valor especificado para el argumento *Attribute* era un atributo de solo lectura.|  
|HY117|La conexión se suspende debido al estado de transacción desconocido. Solo se permiten funciones de desconexión y de solo lectura.|(DM) Para obtener más información sobre el estado suspendido, vea [SqlEndTran (función).](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Característica opcional no implementada|El valor especificado para el argumento *Attribute* era un atributo de instrucción ODBC válido para la versión de ODBC admitida por el controlador, pero no era compatible con el controlador.<br /><br /> El *attribute* argumento se SQL_ATTR_ASYNC_ENABLE y una llamada a **SQLGetInfo** con un *InfoType* de SQL_ASYNC_MODE devuelve SQL_AM_CONNECTION.<br /><br /> El *argumento Attribute* se SQL_ATTR_ENABLE_AUTO_IPD y se SQL_FALSE el valor del atributo connection SQL_ATTR_AUTO_IPD.|  
|HYT01|Tiempo de espera de conexión expirado|El período de tiempo de espera de conexión expiró antes de que el origen de datos respondiera a la solicitud. El período de tiempo de espera de conexión se establece a través de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|El controlador no admite esta función|(DM) El controlador asociado con el *StatementHandle* no admite la función.|  
|S1118|El controlador no admite la notificación asincrónica|Si se llama a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_STMT_EVENT; notificación asincrónica no es compatible con el controlador.|  
  
## <a name="comments"></a>Comentarios  
 Los atributos de instrucción de una instrucción permanecen en vigor hasta que se cambian mediante otra llamada a **SQLSetStmtAttr** o hasta que se quita la instrucción llamando a **SQLFreeHandle**. Llamar a **SQLFreeStmt** con la opción SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS no restablece los atributos de instrucción.  
  
 Algunos atributos de instrucción admiten la sustitución de un valor similar si el origen de datos no admite el valor especificado en *ValuePtr*. En tales casos, el controlador devuelve SQL_SUCCESS_WITH_INFO y SQLSTATE 01S02 (valor de opción cambiado). Por ejemplo, si *Attribute* es SQL_ATTR_CONCURRENCY y *ValuePtr* es SQL_CONCUR_ROWVER, y si el origen de datos no admite esto, el controlador sustituye SQL_CONCUR_VALUES y devuelve SQL_SUCCESS_WITH_INFO. Para determinar el valor sustituido, una aplicación llama a **SQLGetStmtAttr**.  
  
 El formato del conjunto de información con *ValuePtr* depende del *atributo*especificado . **SQLSetStmtAttr** acepta información de atributo en uno de dos formatos diferentes: una cadena de caracteres o un valor entero. El formato de cada uno se indica en la descripción del atributo. Este formato se aplica a la información devuelta para cada atributo en **SQLGetStmtAttr**. Las cadenas de caracteres señaladas por el *argumento ValuePtr* de **SQLSetStmtAttr** tienen una longitud de *StringLength*.  
  
> [!NOTE]
>  La capacidad de establecer atributos de instrucción en el nivel de conexión mediante una llamada a **SQLSetConnectAttr** ha quedado en desuso en ODBC *3.x*. Las aplicaciones ODBC *3.x* nunca deben establecer atributos de instrucción en el nivel de conexión. Los atributos de instrucción ODBC *3.x* no se pueden establecer en el nivel de conexión, con la excepción de los atributos SQL_ATTR_METADATA_ID y SQL_ATTR_ASYNC_ENABLE, que son atributos de conexión y atributos de instrucción, y se pueden establecer en el nivel de conexión o en el nivel de instrucción.  
> 
> [!NOTE]
>  Los controladores ODBC *3.x* solo necesitan admitir esta funcionalidad si deben trabajar con aplicaciones ODBC *2.x* que establezcan opciones de instrucción ODBC *2.x* en el nivel de conexión. Para obtener más información, vea "Configuración de opciones de instrucción en el nivel de conexión" en [SQLSetConnectOption Mapping](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) en apéndice G: directrices de controlador para la compatibilidad con versiones anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrucción que establecen campos descriptores  
 Muchos atributos de instrucción corresponden a un campo de encabezado de un descriptor. Establecer estos atributos realmente da como resultado la configuración de los campos descriptores. Establecer campos mediante una llamada a **SQLSetStmtAttr** en lugar de **sqlSetDescField** tiene la ventaja de que no es necesario obtener un identificador de descriptor para la llamada de función.  
  
> [!CAUTION]  
>  Llamar a **SQLSetStmtAttr** para una instrucción puede afectar a otras instrucciones. Esto ocurre cuando el APD o ARD asociado a la instrucción se asigna explícitamente y también se asocia con otras instrucciones. Dado que **SQLSetStmtAttr** modifica el APD o ARD, las modificaciones se aplican a todas las instrucciones con las que está asociado este descriptor. Si este no es el comportamiento necesario, la aplicación debe disociar este descriptor de las otras instrucciones (mediante una llamada a **SQLSetStmtAttr** para establecer el SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC campo en un identificador de descriptor diferente) antes de llamar a **SQLSetStmtAttr** de nuevo.  
  
 Cuando se establece un campo descriptor como resultado del atributo de instrucción correspondiente que se establece, el campo se establece solo para los descriptores aplicables que están asociados actualmente con la instrucción identificada por el *StatementHandle* argumento y el valor de atributo no afecta a los descriptores que pueden estar asociados con esa instrucción en el futuro. Cuando un campo descriptor que también es un atributo de instrucción se establece mediante una llamada a **SQLSetDescField**, se establece el atributo de instrucción correspondiente. Si un descriptor asignado explícitamente se disocia de una instrucción, un atributo de instrucción que corresponde a un campo de encabezado revertirá al valor del campo en el descriptor asignado implícitamente.  
  
 Cuando se asigna una instrucción (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), cuatro identificadores de descriptor se asignan automáticamente y se asocian a la instrucción. Los identificadores de descriptor asignados explícitamente se pueden asociar a la instrucción llamando a **SQLAllocHandle** con un *fHandleType* de SQL_HANDLE_DESC para asignar un identificador de descriptor y, a continuación, llamando a **SQLSetStmtAttr** para asociar el identificador de descriptor con la instrucción.  
  
 Los atributos de instrucción de la tabla siguiente corresponden a campos de encabezado descriptor.  
  
|Atributo de instrucción|Campo de cabecera|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Atributos de instrucción  
 Los atributos definidos actualmente y la versión de ODBC en la que se introdujeron se muestran en la tabla siguiente; se espera que los controladores definan más atributos para aprovechar los diferentes orígenes de datos. ODBC reserva un intervalo de atributos; los desarrolladores de controladores deben reservar valores para su propio uso específico del controlador de Open Group. Para obtener más información, vea [Tipos de datos específicos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md)del controlador, Tipos de descriptor, Tipos de información, Tipos de diagnóstico y Atributos .  
  
|Atributo|*Contenido valuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|El identificador de la APD para las llamadas posteriores a **SQLExecute** y **SQLExecDirect** en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando se asignó inicialmente la instrucción. Si el valor de este atributo se establece en SQL_NULL_DESC o el identificador asignado originalmente para el descriptor, un identificador de APD asignado explícitamente que se asoció anteriormente con el identificador de instrucción se disocia de él y el identificador de instrucción vuelve al identificador de APD asignado implícitamente.<br /><br /> Este atributo no se puede establecer en un identificador de descriptor que se asignó implícitamente para otra instrucción o a otro identificador de descriptor que se estableció implícitamente en la misma instrucción; Los identificadores de descriptor asignados implícitamente no se pueden asociar a más de una instrucción o identificador de descriptor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|El identificador de ARD para las capturas posteriores en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando se asignó inicialmente la instrucción. Si el valor de este atributo se establece en SQL_NULL_DESC o el identificador asignado originalmente para el descriptor, un identificador ARD asignado explícitamente que se asoció anteriormente con el identificador de instrucción se disocia de él y el identificador de instrucción vuelve al identificador ARD asignado implícitamente.<br /><br /> Este atributo no se puede establecer en un identificador de descriptor que se asignó implícitamente para otra instrucción o a otro identificador de descriptor que se estableció implícitamente en la misma instrucción; Los identificadores de descriptor asignados implícitamente no se pueden asociar a más de una instrucción o identificador de descriptor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Un valor SQLULEN que especifica si una función a la que se llama con la instrucción especificada se ejecuta de forma asincrónica:<br /><br /> SQL_ASYNC_ENABLE_OFF: deshabilitar la compatibilidad de ejecución asincrónica de nivel de instrucción (valor predeterminado).<br /><br /> SQL_ASYNC_ENABLE_ON: Habilitar la compatibilidad de ejecución asincrónica de nivel de instrucción.<br /><br /> Para obtener más información, vea [Ejecución asincrónica (método de sondeo).](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md)<br /><br /> Para los controladores con compatibilidad de ejecución asincrónica de nivel de instrucción, el atributo de instrucción SQL_ATTR_ASYNC_ENABLE es de solo lectura. Su valor es el mismo que el valor del atributo de nivel de conexión con el mismo nombre en el momento en que se asignó el identificador de instrucción.<br /><br /> Llamar a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_ENABLE cuando el *SQL_ASYNC_MODE InfoType* devuelve SQL_AM_CONNECTION devuelve SQLSTATE HYC00 (característica opcional no implementada). Para obtener más información, vea [SQLSetConnectAttr (función)](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obtener más información.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Un valor SQLPOINTER que es un identificador de evento.<br /><br /> Notificación de finalización de funciones asincrónicas se habilita mediante una llamada a **SQLSetStmtAttr** para establecer el **SQL_ATTR_ASYNC_STMT_EVENT** atributo y especificar el identificador de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER a la función de devolución de llamada asincrónica.<br /><br /> Solo el Administrador de controladores puede llamar a la función **SQLSetStmtAttr** de un controlador con este atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER a la estructura de contexto<br /><br /> Solo el Administrador de controladores puede llamar a la función **SQLSetStmtAttr** de un controlador con este atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Un valor SQLULEN que especifica la simultaneidad del cursor:<br /><br /> SQL_CONCUR_READ_ONLY - El cursor es de solo lectura. No se permiten actualizaciones.<br /><br /> SQL_CONCUR_LOCK - Cursor utiliza el nivel más bajo de bloqueo suficiente para asegurarse de que la fila se puede actualizar.<br /><br /> SQL_CONCUR_ROWVER cursor utiliza el control de simultaneidad optimista, comparando versiones de fila como SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES: cursor utiliza un control de simultaneidad optimista, comparando valores.<br /><br /> El valor predeterminado para SQL_ATTR_CONCURRENCY es SQL_CONCUR_READ_ONLY.<br /><br /> Este atributo no se puede especificar para un cursor abierto. Para obtener más información, vea Tipos de [simultaneidad](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si el *atributo* SQL_ATTR_CURSOR_TYPE se cambia a un tipo que no admite el valor actual de SQL_ATTR_CONCURRENCY, el valor de SQL_ATTR_CONCURRENCY se cambiará en tiempo de ejecución y se emitirá una advertencia cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si el controlador admite la instrucción **SELECT FOR UPDATE** y dicha instrucción se ejecuta mientras el valor de SQL_ATTR_CONCURRENCY se establece en SQL_CONCUR_READ_ONLY, se devolverá un error. Si el valor de SQL_ATTR_CONCURRENCY se cambia a un valor que el controlador admite para algún valor de SQL_ATTR_CURSOR_TYPE pero no para el valor actual de SQL_ATTR_CURSOR_TYPE, el valor de SQL_ATTR_CURSOR_TYPE se cambiará en tiempo de ejecución y SQLSTATE 01S02 (option value changed) se emite cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si el origen de datos no admite la simultaneidad especificada, el controlador sustituye una simultaneidad diferente y devuelve SQLSTATE 01S02 (valor de opción cambiado). Por SQL_CONCUR_VALUES, el conductor sustituye SQL_CONCUR_ROWVER y viceversa. Por SQL_CONCUR_LOCK, el conductor sustituye, en orden, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. La validez del valor sustituido no se comprueba hasta el tiempo de ejecución.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CONCURRENCY y los demás atributos del cursor, vea [Características del cursor y Tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)de cursor .|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Un valor SQLULEN que especifica el nivel de compatibilidad que requiere la aplicación. Establecer este atributo afecta a las llamadas posteriores a **SQLExecDirect** y **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE: no se requieren cursores desplazables en el identificador de instrucción. Si la aplicación llama a **SQLFetchScroll** en este identificador, el único valor válido de *FetchOrientation* se SQL_FETCH_NEXT. Este es el valor predeterminado.<br /><br /> SQL_SCROLLABLE: se requieren cursores desplazables en el identificador de instrucción. Al llamar a **SQLFetchScroll**, la aplicación puede especificar cualquier valor válido de *FetchOrientation*, logrando el posicionamiento del cursor en modos distintos del modo secuencial.<br /><br /> Para obtener más información acerca de los cursores desplazables, vea [Cursores desplazables](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SCROLLABLE y los demás atributos del cursor, consulte [Características del cursor y Tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un valor SQLULEN que especifica si los cursores en el identificador de instrucción hacen visibles los cambios realizados en un conjunto de resultados por otro cursor. Establecer este atributo afecta a las llamadas posteriores a **SQLExecDirect** y **SQLExecute**. Una aplicación puede leer el valor de este atributo para obtener su estado inicial o su estado como establecido más recientemente por la aplicación.<br /><br /> SQL_UNSPECIFIED: no se especifica cuál es el tipo de cursor y si los cursores en el identificador de instrucción hacen visibles los cambios realizados en un conjunto de resultados por otro cursor. Los cursores en el identificador de instrucción pueden hacer visible ninguno, algunos o todos estos cambios. Este es el valor predeterminado.<br /><br /> SQL_INSENSITIVE: todos los cursores del identificador de instrucción muestran el conjunto de resultados sin reflejar los cambios realizados en él por ningún otro cursor. Los cursores insensibles son de solo lectura. Esto corresponde a un cursor estático, que tiene una simultaneidad que es de solo lectura.<br /><br /> SQL_SENSITIVE: todos los cursores del identificador de instrucción hacen visibles todos los cambios realizados en un conjunto de resultados por otro cursor.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SENSITIVITY y los demás atributos del cursor, vea [Características del cursor y Tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)de cursor .|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Un valor SQLULEN que especifica el tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY: el cursor solo se desplaza hacia delante.<br /><br /> SQL_CURSOR_STATIC: los datos del conjunto de resultados son estáticos.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN: el controlador guarda y utiliza las claves para el número de filas especificadas en el atributo de instrucción SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC: el controlador guarda y utiliza solo las claves de las filas del conjunto de filas.<br /><br /> El valor predeterminado es SQL_CURSOR_FORWARD_ONLY. Este atributo no se puede especificar después de que se haya preparado la instrucción SQL.<br /><br /> Si el origen de datos no admite el tipo de cursor especificado, el controlador sustituye un tipo de cursor diferente y devuelve SQLSTATE 01S02 (valor de opción cambiado). Para un cursor mixto o dinámico, el controlador sustituye, en orden, un cursor estático o controlado por conjunto de claves. Para un cursor controlado por conjunto de claves, el controlador sustituye un cursor estático.<br /><br /> Para obtener más información acerca de los tipos de cursor desplazables, vea Tipos de [cursor desplazables](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_TYPE y los demás atributos del cursor, vea [Características del cursor y Tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)de cursor .|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Un valor SQLULEN que especifica si se realiza la población automática de la IPD:<br /><br /> SQL_TRUE: activa la población automática de LA IPD después de una llamada a **SQLPrepare**. SQL_FALSE: desactiva la población automática de la IPD después de una llamada a **SQLPrepare**. (Una aplicación todavía puede obtener información de campo IPD llamando a **SQLDescribeParam**, si se admite.) El valor predeterminado del atributo de instrucción SQL_ATTR_ENABLE_AUTO_IPD es SQL_FALSE. Para obtener más información, consulte [Población automática de la IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|SQLLEN \* que apunta a un valor de marcador binario. Cuando **SQLFetchScroll** se llama con *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, el controlador recoge el valor del marcador de este campo. Este campo tiene como valor predeterminado un puntero nulo. Para obtener más información, consulte [Desplazamiento por marcador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> El valor al que apunta este campo no se utiliza para eliminar por marcador, actualizar por marcador o capturar por operaciones de marcador en **SQLBulkOperations**, que usan marcadores almacenados en caché en búferes de conjunto de filas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|El identificador del IPD. El valor de este atributo es el descriptor asignado cuando se asignó inicialmente la instrucción. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecido mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|El mango del IRD. El valor de este atributo es el descriptor asignado cuando se asignó inicialmente la instrucción. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecido mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|SQLULEN que especifica el número de filas del conjunto de claves para un cursor controlado por conjunto de claves. Si el tamaño del conjunto de claves es 0 (valor predeterminado), el cursor está completamente controlado por el conjunto de claves. Si el tamaño del conjunto de claves es mayor que 0, el cursor se mezcla (controlado por conjunto de claves dentro del conjunto de claves y dinámico fuera del conjunto de claves). El tamaño predeterminado del conjunto de claves es 0. Para obtener más información acerca de los cursores controlados por conjuntos de claves, vea [Cursores controlados por conjuntos de claves](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si el tamaño especificado supera el tamaño máximo del conjunto de claves, el controlador sustituye ese tamaño y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> **SQLFetch** o **SQLFetchScroll** devuelve un error si el tamaño del conjunto de claves es mayor que 0 y menor que el tamaño del conjunto de filas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Un valor SQLULEN que especifica la cantidad máxima de datos que el controlador devuelve de un carácter o columna binaria. Si *ValuePtr* es menor que la longitud de los datos disponibles, **SQLFetch** o **SQLGetData** trunca los datos y devuelve SQL_SUCCESS. Si *ValuePtr* es 0 (valor predeterminado), el controlador intenta devolver todos los datos disponibles.<br /><br /> Si la longitud especificada es menor que la cantidad mínima de datos que el origen de datos puede devolver o mayor que la cantidad máxima de datos que puede devolver el origen de datos, el controlador sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.<br /><br /> Este atributo está pensado para reducir el tráfico de red y debe admitirse solo cuando el origen de datos (a diferencia del controlador) en un controlador de varios niveles puede implementarlo. Las aplicaciones no deben utilizar este mecanismo para truncar los datos; para truncar los datos recibidos, una aplicación debe especificar la longitud máxima del búfer en el argumento *BufferLength* en **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Un valor SQLULEN correspondiente al número máximo de filas que se devolverán a la aplicación para una instrucción **SELECT.** Si \* *ValuePtr* es igual a 0 (valor predeterminado), el controlador devuelve todas las filas.<br /><br /> Este atributo está pensado para reducir el tráfico de red. Conceptualmente, se aplica cuando se crea el conjunto de resultados y limita el conjunto de resultados a las primeras filas *ValuePtr.* Si el número de filas del conjunto de resultados es mayor que *ValuePtr*, el conjunto de resultados se trunca.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos los conjuntos de resultados de la *instrucción*, incluidos los devueltos por las funciones de catálogo. SQL_ATTR_MAX_ROWS establece un máximo para el valor del recuento de filas del cursor.<br /><br /> Un controlador no debe emular SQL_ATTR_MAX_ROWS comportamiento para **SQLFetch** o **SQLFetchScroll** (si las limitaciones de tamaño del conjunto de resultados no se pueden implementar en el origen de datos) si no puede garantizar que SQL_ATTR_MAX_ROWS se implementará correctamente.<br /><br /> Está definido por el controlador si SQL_ATTR_MAX_ROWS se aplica a instrucciones distintas de las instrucciones SELECT (como las funciones de catálogo).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Un valor SQLULEN que determina cómo se tratan los argumentos de cadena de las funciones de catálogo.<br /><br /> Si SQL_TRUE, el argumento de cadena de las funciones de catálogo se tratan como identificadores. El caso no es significativo. Para las cadenas no delimitadas, el controlador quita los espacios finales y la cadena se pliega en mayúsculas. Para las cadenas delimitadas, el controlador quita los espacios iniciales o finales y toma lo que esté entre los delimitadores literalmente. Si uno de estos argumentos se establece en un puntero nulo, la función devuelve SQL_ERROR y SQLSTATE HY009 (uso no válido del puntero nulo).<br /><br /> Si SQL_FALSE, los argumentos de cadena de las funciones de catálogo no se tratan como identificadores. El caso es significativo. Pueden contener un patrón de búsqueda de cadena o no, dependiendo del argumento.<br /><br /> El valor predeterminado es SQL_FALSE.<br /><br /> El argumento *TableType* de **SQLTables**, que toma una lista de valores, no se ve afectado por este atributo.<br /><br /> SQL_ATTR_METADATA_ID también se puede establecer en el nivel de conexión. (It y SQL_ATTR_ASYNC_ENABLE son los únicos atributos de instrucción que también son atributos de conexión.)<br /><br /> Para obtener más información, vea [Argumentos en funciones](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md)de catálogo .|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Un valor SQLULEN que indica si el controlador debe examinar cadenas SQL en busca de secuencias de escape:<br /><br /> SQL_NOSCAN_OFF: el controlador examina las cadenas SQL en busca de secuencias de escape (valor predeterminado).<br /><br /> SQL_NOSCAN_ON: el controlador no analiza cadenas SQL en busca de secuencias de escape. En su lugar, el controlador envía la instrucción directamente al origen de datos.<br /><br /> Para obtener más información, vea [Secuencias](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md)de escape en ODBC .|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un valor SQLULEN * que apunta a un desplazamiento agregado a punteros para cambiar el enlace de parámetros dinámicos. Si este campo no es null, el controlador desreferencia el puntero, agrega el valor desreferenciado a cada uno de los campos diferidos en el registro descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y utiliza los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> El desplazamiento de enlace siempre se agrega directamente a los campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR. Si el desplazamiento se cambia a un valor diferente, el nuevo valor se sigue agregando directamente al valor en el campo descriptor. El nuevo desplazamiento no se agrega al valor del campo más los desfases anteriores.<br /><br /> Para obtener más información, vea Desplazamientos de enlace de [parámetros](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Al establecer este atributo de instrucción se establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Un valor SQLULEN que indica la orientación de enlace que se usará para los parámetros dinámicos.<br /><br /> Este campo se establece en SQL_PARAM_BIND_BY_COLUMN (valor predeterminado) para seleccionar el enlace de columna.<br /><br /> Para seleccionar el enlace de fila, este campo se establece en la longitud de la estructura o una instancia de un búfer que se enlazará a un conjunto de parámetros dinámicos. Esta longitud debe incluir espacio para todos los parámetros enlazados y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de un parámetro enlazado se incrementa con la longitud especificada, el resultado apuntará al principio del mismo parámetro en el siguiente conjunto de parámetros. Cuando se utiliza el operador *sizeof* en ANSI C, este comportamiento está garantizado.<br /><br /> Para obtener más información, vea [Binding Arrays of Parameters](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ BIND_TYPE en el encabezado APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un valor SQLUSMALLINT \* que apunta a una matriz de valores SQLUSMALLINT que se usan para omitir un parámetro durante la ejecución de una instrucción SQL. Cada valor se establece en SQL_PARAM_PROCEED (para que se ejecute el parámetro) o SQL_PARAM_IGNORE (para que se ignore el parámetro).<br /><br /> Un conjunto de parámetros se puede omitir durante el procesamiento estableciendo el valor de estado en la matriz a la que apunta SQL_DESC_ARRAY_STATUS_PTR en el APD en SQL_PARAM_IGNORE. Se procesa un conjunto de parámetros si su valor de estado se establece en SQL_PARAM_PROCEED o si no se establece ningún elemento de la matriz.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de parámetro. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez **SQLExecDirect** o **SQLExecute** se llama.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [Uso de matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un valor SQLUSMALLINT \* que apunta a una matriz de valores SQLUSMALLINT que contiene información de estado para cada fila de valores de parámetro después de una llamada a **SQLExecute** o **SQLExecDirect**. Este campo solo es necesario si PARAMSET_SIZE es mayor que 1.<br /><br /> Los valores de estado pueden contener los siguientes valores:<br /><br /> SQL_PARAM_SUCCESS: La instrucción SQL se ejecutó correctamente para este conjunto de parámetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: la instrucción SQL se ejecutó correctamente para este conjunto de parámetros; sin embargo, la información de advertencia está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Se ha producido un error al procesar este conjunto de parámetros. Información de error adicional está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Este conjunto de parámetros no se utilizó, posiblemente debido al hecho de que algún conjunto de parámetros anterior causó un error que anuló el procesamiento posterior, o porque SQL_PARAM_IGNORE se estableció para ese conjunto de parámetros en la matriz especificada por el SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: El controlador trata las matrices de parámetros como una unidad monolítica y, por lo tanto, no genera este nivel de información de error.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de parámetro. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez **SQLExecute** o **SQLExecDirect** se llama. Tenga en cuenta que establecer este atributo puede afectar al comportamiento del parámetro de salida implementado por el controlador.<br /><br /> Para obtener más información, consulte [Uso de matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un campo \* de registro SQLULEN que apunta a un búfer en el que se va a devolver el número de conjuntos de parámetros que se han procesado, incluidos los conjuntos de errores. No se devolverá ningún número si se trata de un puntero nulo.<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IPD.<br /><br /> Si la llamada a **SQLExecDirect** o **SQLExecute** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.<br /><br /> Para obtener más información, consulte [Uso de matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de valores para cada parámetro. Si SQL_ATTR_PARAMSET_SIZE es mayor que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR del punto APD a matrices. La cardinalidad de cada matriz es igual al valor de este campo.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [Uso de matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción se establece el campo SQL_DESC_ARRAY_SIZE en el encabezado APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Un valor SQLULEN correspondiente al número de segundos que se debe esperar a que se ejecute una instrucción SQL antes de volver a la aplicación. Si *ValuePtr* es igual a 0 (valor predeterminado), no hay tiempo de espera.<br /><br /> Si el tiempo de espera especificado supera el tiempo de espera máximo en el origen de datos o es menor que el tiempo de espera mínimo, **SQLSetStmtAttr** sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> Tenga en cuenta que la aplicación no necesita llamar a **SQLCloseCursor** para reutilizar la instrucción si se adelantó el tiempo de espera de una instrucción **SELECT.**<br /><br /> El tiempo de espera de consulta establecido en este atributo de instrucción es válido en los modos sincrónico y asincrónico.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valor SQLULEN:<br /><br /> SQL_RD_ON **SQLFetchScroll** y, en ODBC *3.x*, **SQLFetch** recuperar datos después de colocar el cursor en la ubicación especificada. Este es el valor predeterminado.<br /><br /> SQL_RD_OFF **SQLFetchScroll** y, en ODBC *3.x*, **SQLFetch** no recupera datos después de colocar el cursor.<br /><br /> Al establecer SQL_RETRIEVE_DATA en SQL_RD_OFF, una aplicación puede comprobar que existe una fila o recuperar un marcador para la fila sin incurrir en la sobrecarga de recuperar filas. Para obtener más información, consulte [Desplazamiento y obtención de filas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de filas devueltas por cada llamada a **SQLFetch** o **SQLFetchScroll**. También es el número de filas de una matriz de marcadores utilizada en una operación de marcador masivo en **SQLBulkOperations**. El valor predeterminado es 1.<br /><br /> Si el tamaño del conjunto de filas especificado supera el tamaño máximo del conjunto de filas admitido por el origen de datos, el controlador sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> Para obtener más información, consulte [Tamaño del conjunto](../../../odbc/reference/develop-app/rowset-size.md)de filas .<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_SIZE en el encabezado ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un valor SQLULEN * que apunta a un desplazamiento agregado a punteros para cambiar el enlace de datos de columna. Si este campo no es null, el controlador desreferencia el puntero, agrega el valor desreferenciado a cada uno de los campos diferidos en el registro descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y utiliza los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Un valor SQLULEN que establece la orientación de enlace que se usará cuando **SQLFetch** o **SQLFetchScroll** se llama en la instrucción asociada. El enlace de columna se selecciona estableciendo el valor en SQL_BIND_BY_COLUMN. El enlace de fila se selecciona estableciendo el valor en la longitud de una estructura o una instancia de un búfer en el que se enlazarán las columnas de resultados.<br /><br /> Si se especifica una longitud, debe incluir espacio para todas las columnas enlazadas y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de una columna enlazada se incrementa con la longitud especificada, el resultado apuntará al principio de la misma columna en la fila siguiente. Cuando se utiliza el **operador sizeof** con estructuras o uniones en ANSI C, se garantiza este comportamiento.<br /><br /> El enlace de columna es la orientación de enlace predeterminada para **SQLFetch** y **SQLFetchScroll**.<br /><br /> Para obtener más información, vea [Enlazar columnas para usar con cursores](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md)de bloque .<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_BIND_TYPE en el encabezado ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Un valor SQLULEN que es el número de la fila actual en todo el conjunto de resultados. Si no se puede determinar el número de la fila actual o no hay ninguna fila actual, el controlador devuelve 0.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecido mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Valor SQLUSMALLINT \* que apunta a una matriz de valores SQLUSMALLINT que se usan para omitir una fila durante una operación masiva mediante **SQLSetPos**. Cada valor se establece en SQL_ROW_PROCEED (para que la fila se incluya en la operación masiva) o SQL_ROW_IGNORE (para que la fila se excluya de la operación masiva). (Las filas no se pueden omitir mediante el uso de esta matriz durante las llamadas a **SQLBulkOperations**.)<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez **SQLSetPos** se llama.<br /><br /> Para obtener más información, vea Actualizar filas en el conjunto de [filas con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) y Eliminar filas en el conjunto de [filas con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Valor SQLUSMALLINT \* que apunta a una matriz de valores SQLUSMALLINT que contienen valores de estado de fila después de una llamada a **SQLFetch** o **SQLFetchScroll**. La matriz tiene tantos elementos como filas en el conjunto de filas.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**o **SQLSetPos** se llama.<br /><br /> Para obtener más información, consulte [Número de filas capturadas y Estado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IRD.<br /><br /> Este atributo se asigna mediante un controlador ODBC *2.x* a la matriz *rgbRowStatus* en una llamada a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un valor \* SQLULEN que apunta a un búfer en el que se devuelve el número de filas obtenidas después de una llamada a **SQLFetch** o **SQLFetchScroll**; el número de filas afectadas por una operación masiva realizada por una llamada a **SQLSetPos** con un *Operación* argumento de SQL_REFRESH; o el número de filas afectadas por una operación masiva realizada por **SQLBulkOperations**. Este número incluye filas de error.<br /><br /> Para obtener más información, consulte [Número de filas capturadas y Estado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IRD.<br /><br /> Si la llamada a **SQLFetch** o **SQLFetchScroll** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Un valor SQLULEN que especifica si los controladores que simulan instrucciones de actualización y eliminación posicionadas garantizan que estas instrucciones afectan a una sola fila.<br /><br /> Para simular instrucciones de actualización y eliminación posicionadas, la mayoría de los controladores construyen una instrucción **UPDATE** o **DELETE** buscada que contiene una cláusula **WHERE** que especifica el valor de cada columna de la fila actual. A menos que estas columnas conforman una clave única, dicha instrucción puede afectar a más de una fila.<br /><br /> Para garantizar que estas instrucciones afectan a una sola fila, el controlador determina las columnas de una clave única y agrega estas columnas al conjunto de resultados. Si una aplicación garantiza que las columnas del conjunto de resultados componen una clave única, no es necesario que el controlador lo haga. Esto puede reducir el tiempo de ejecución.<br /><br /> SQL_SC_NON_UNIQUE: el controlador no garantiza que las instrucciones de actualización o eliminación posicionadas simuladas afectarán a una sola fila; es responsabilidad de la aplicación hacerlo. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de operación de cursor).<br /><br /> SQL_SC_TRY_UNIQUE: el controlador intenta garantizar que las instrucciones de actualización o eliminación posicionadas simuladas solo afectan a una fila. El controlador siempre ejecuta estas instrucciones, incluso si pueden afectar a más de una fila, como cuando no hay ninguna clave única. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de operación de cursor).<br /><br /> SQL_SC_UNIQUE: el controlador garantiza que las instrucciones de actualización o eliminación posicionadas simuladas solo afectan a una fila. Si el controlador no puede garantizar esto para una instrucción determinada, **SQLExecDirect** o **SQLPrepare** devuelve un error.<br /><br /> Si el origen de datos proporciona compatibilidad sql nativa para instrucciones de actualización y eliminación posicionadas y el controlador no simula cursores, se devuelve SQL_SUCCESS cuando se solicita SQL_SC_UNIQUE para SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO se devuelve si se solicita SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Si el origen de datos proporciona el nivel de soporte técnico SQL_SC_TRY_UNIQUE y el controlador no, se devuelve SQL_SUCCESS para SQL_SC_TRY_UNIQUE y SQL_SUCCESS_WITH_INFO se devuelve para SQL_SC_NON_UNIQUE.<br /><br /> Si el origen de datos no admite el tipo de simulación de cursor especificado, el controlador sustituye un tipo de simulación diferente y devuelve SQLSTATE 01S02 (valor de opción cambiado). Por SQL_SC_UNIQUE, el conductor sustituye, en orden, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Por SQL_SC_TRY_UNIQUE, el conductor sustituye SQL_SC_NON_UNIQUE.<br /><br /> El valor predeterminado es SQL_SC_UNIQUE.<br /><br /> Para obtener más información, consulte Simulación de instrucciones de [actualización y eliminación posicionadas](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Un valor SQLULEN que especifica si una aplicación usará marcadores con un cursor:<br /><br /> SQL_UB_OFF de opción desactivada (valor predeterminado)<br /><br /> SQL_UB_VARIABLE: una aplicación usará marcadores con un cursor y el controlador proporcionará marcadores de longitud variable si son compatibles. SQL_UB_FIXED está en desuso en ODBC *3.x*. Las aplicaciones ODBC *3.x* siempre deben usar marcadores de longitud variable, incluso cuando se trabaja con controladores ODBC *2.x* (que solo admiten marcadores de 4 bytes de longitud fija). Esto se debe a que un marcador de longitud fija es solo un caso especial de un marcador de longitud variable. Cuando se trabaja con un controlador ODBC *2.x,* el Administrador de controladores asigna SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Para utilizar marcadores con un cursor, la aplicación debe especificar este atributo con el valor SQL_UB_VARIABLE antes de abrir el cursor.<br /><br /> Para obtener más información, consulte [Recuperación de marcadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Estas funciones se pueden llamar de forma asincrónica solo si el descriptor es un descriptor de implementación, no un descriptor de aplicación.  
  
 Consulte [Encuadernación](../../../odbc/reference/develop-app/column-wise-binding.md) de columna y enlace de [fila.](../../../odbc/reference/develop-app/row-wise-binding.md)  
  
## <a name="related-functions"></a>Funciones relacionadas  
  
|Para información acerca de|Vea|  
|---------------------------|---------|  
|Cancelación del procesamiento de extractos|[Función SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Devolver la configuración de un atributo de conexión|[Función SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Devolver la configuración de un atributo de instrucción|[Función SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Establecer un atributo de conexión|[Función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Establecer un único campo del descriptor|[Función SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Consulte también  
 [Referencia de la API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Archivos de encabezado de ODBC](../../../odbc/reference/install/odbc-header-files.md)
