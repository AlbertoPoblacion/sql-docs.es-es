---
title: 'O2SS0007: condición de restricción CHECK no analizada (error)'
description: Trata la razón por la que SQL Server Migration Assistant (SSMA) para Oracle no puede convertir una columna de BINARY_FLOAT con una restricción para comprobar una condición NAN (no un número).
authors: nahk-ivanov
ms.service: ssma
ms.devlang: sql
ms.topic: article
ms.date: 1/22/2020
ms.author: alexiva
ms.openlocfilehash: 01e7d2baefef20f854dcb080826d69e1efabb212
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/27/2020
ms.locfileid: "76762809"
---
# <a name="o2ss0007-check-constraint-condition-not-parsed-error"></a>O2SS0007: condición de restricción CHECK no analizada (error)

En este artículo se describe el motivo por el que SQL Server Migration Assistant (SSMA) para Oracle no puede `BINARY_FLOAT` convertir una columna con una restricción para `NAN` comprobar una condición (no es un número).

## <a name="background"></a>Segundo plano

En Oracle, el `BINARY_FLOAT` tipo de datos permite a una aplicación almacenar los valores de desbordamiento o subdesbordamiento de número. SQL Server genera un error en cuanto se calcula un desbordamiento de número o subdesbordamiento y, por tanto, no puede almacenar el `FLOAT` valor en un tipo de datos. Al intentar convertir el esquema de una tabla que tiene una condición de restricción que está comprobando `NAN` los valores, SSMA genera un error porque SQL Server no admite condiciones de punto `NAN`flotante como.

## <a name="example"></a>Ejemplo

Considere el ejemplo siguiente, donde se ha creado una tabla y se ha modificado mediante la adición `NAN` de una restricción de tipo:

```sql
CREATE TABLE NANTEST
(
    COL1 BINARY_FLOAT
);
/

ALTER TABLE NANTEST ADD CONSTRAINT NANCHECK1 CHECK (COL1 IS NOT NAN);
```

Al intentar convertir el esquema de la tabla anterior en SSMA, se genera el siguiente mensaje de error:

> O2SS0007: condición de restricción CHECK no analizada

## <a name="possible-remedies"></a>Posibles soluciones

La solución al ejemplo anterior se puede dividir en dos pasos:

**Paso 1:** Cree una nueva tabla en SQL Server sin la restricción check:

```sql
CREATE TABLE NANTEST
(
    COL1 FLOAT(53)
)
```

Equivalente a `BINARY_FLOAT` en SQL Server es `FLOAT(53)`.

**Paso 2:** Modifique el código de aplicación para insertar los valores en esta tabla. Cree un `TRY .. CATCH` bloque que impedirá que los usuarios inserten un valor no admitido y generen un mensaje de error similar a un error generado a partir de una restricción check:

```sql
DECLARE
    @VAL FLOAT(53)

BEGIN TRY
    SET @VAL = 1 / 0

    INSERT INTO NANTEST VALUES (@VAL)
END TRY
BEGIN CATCH
    PRINT(
        'SQL error is ' + CONVERT(varchar(20), ERROR_NUMBER())
            + ' : ' + CONVERT(varchar(100), ERROR_MESSAGE()))
END CATCH;
```

> [!IMPORTANT]
> Intentar usar `ISNUMERIC()` la función en una restricción CHECK para este escenario no es una solución viable, porque `ISNUMERIC()` está diseñado para comprobar las cadenas que pueden representar valores numéricos y no condiciones de desbordamiento y subdesbordamiento numérico.
